#!/bin/bash
# Autor: ssmax
# Versión: 3.1 corregida
# Descripción: Script de pentest ético para Solana testnet/mainnet – Etapa 1: Reconocimiento

set -euo pipefail
IFS=$'\n\t'

# ==== CONFIGURACIÓN ====
TARGET=${1:-""}
[ -z "$TARGET" ] && { echo "Uso: $0 <IP_objetivo>"; exit 1; }
[[ "$TARGET" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "IP inválida: $TARGET"; exit 1; }

OUTPUT_DIR="pentest_$TARGET"
WORDLIST="/usr/share/wordlists/rockyou.txt"
USERLIST="/usr/share/wordlists/usernames.txt"
LOG_FILE="$OUTPUT_DIR/log.txt"

# Colores terminal
RED='\033[0;31m'; GREEN='\033[0;32m'
YELLOW='\033[1;33m'; BLUE='\033[0;34m'; NC='\033[0m'

# Arrays y variables
declare -a VULNERABILITIES_FOUND=()
declare -a POC_REFERENCES=()
PORTS=""
FILTERED_PORTS=""

# ==== FUNCIONES DE LOG ====
timestamp(){ date +"%Y-%m-%d %H:%M:%S"; }
log(){ echo -e "${BLUE}[$(timestamp)] [*]${NC} $1" | tee -a "$LOG_FILE"; }
success(){ echo -e "${GREEN}[$(timestamp)] [OK]${NC} $1" | tee -a "$LOG_FILE"; }
error(){ echo -e "${RED}[$(timestamp)] [FAIL] ERROR:${NC} $1" | tee -a "$LOG_FILE"; }
info(){ echo -e "${YELLOW}[$(timestamp)] [!]${NC} $1" | tee -a "$LOG_FILE"; }

# ==== SPINNER ====
spinner(){
  local p="$1"; local d=0.1; local s='|/-\'
  while kill -0 "$p" &>/dev/null; do
    local t=${s#?}; printf " [%c]  " "$s"
    s=$t${s%"$t"}; sleep $d; printf "\b\b\b\b\b\b"
  done; printf "      \b\b\b\b\b\b"
}
run_with_spinner(){ "$@" & spinner $!; wait $!; }

# ==== VERIFICACIÓN DE REQUISITOS ====
check_requirements(){
  log "Verificando herramientas necesarias..."
  for t in nmap whatweb httpx curl nuclei; do
    command -v "$t" &>/dev/null || { error "Falta: $t"; exit 1; }
  done
  [ -f "$WORDLIST" ] || { error "Wordlist faltante."; exit 1; }
  [ -f "$USERLIST" ] || {
    log "Creando userlist básica..."
    echo -e "root\nadmin\nuser\ntest\nguest" > "$USERLIST"
    success "Userlist creada."
  }
}

# ==== ESCANEO DE PUERTOS ====
full_port_scan(){
  log "Escaneando puertos TCP..."
  run_with_spinner nmap -vv -sS -sV -O -Pn -T4 -p- "$TARGET" -oN "$OUTPUT_DIR/nmap_full.txt"
  PORTS=$(grep 'open' "$OUTPUT_DIR/nmap_full.txt" | cut -d '/' -f1 | paste -sd ',' -)
  FILTERED_PORTS=$(grep 'filtered' "$OUTPUT_DIR/nmap_full.txt" | cut -d '/' -f1 | paste -sd ',' -)
  [ -z "$PORTS" ] && { error "No hay puertos abiertos."; exit 1; }
  success "Puertos abiertos: $PORTS"
  [ -n "$FILTERED_PORTS" ] && info "Puertos filtrados: $FILTERED_PORTS"
}

# ==== ESCANEO DETALLADO ====
detailed_scan(){
  log "Escaneo detallado..."
  run_with_spinner nmap -sC -sV --script=banner -p"$PORTS" "$TARGET" -oN "$OUTPUT_DIR/nmap_detail.txt"
  success "Escaneo detallado completado."
}

# ==== ESCANEO DE VULNERABILIDADES ====
vulnerability_scan(){
  log "Escaneo de vulnerabilidades con Nmap..."
  run_with_spinner nmap -sV --script vuln -p"$PORTS" "$TARGET" -oN "$OUTPUT_DIR/nmap_vuln.txt"
  success "Escaneo NSE completado."
  grep -iq "VULNERABLE" "$OUTPUT_DIR/nmap_vuln.txt" || info "Sin vulnerabilidades evidentes."

  log "Escaneo de vulnerabilidades con Nuclei..."
  echo "$TARGET" > "$OUTPUT_DIR/target.txt"
  nuclei -l "$OUTPUT_DIR/target.txt" -o "$OUTPUT_DIR/nuclei_results.txt" -silent || true
  success "Escaneo Nuclei completado."
}

# ==== ESCANEO HTTP ====
web_banner_scan(){
  log "Verificando puertos HTTP..."

  local web_ports=()
  for p in $(echo "$PORTS" | tr ',' ' '); do
    if [[ "$p" =~ ^(80|443|8080|8000|8008|8015|8020|8899)$ ]]; then
      web_ports+=("$p")
    fi
  done

  if [ ${#web_ports[@]} -eq 0 ]; then
    info "No se detectaron puertos web."
    return
  fi

  log "Escaneando HTTP con httpx y whatweb..."
  for p in "${web_ports[@]}"; do
    httpx -silent -p "$p" -host "$TARGET" -title -server -status-code > "$OUTPUT_DIR/httpx_$p.txt" || true
    whatweb "$TARGET:$p" > "$OUTPUT_DIR/whatweb_$p.txt" || true
    success "HTTP escaneado @ $p"
  done
}

# ==== DETECCIÓN DE SERVICIOS CON AUTENTICACIÓN ====
detect_auth_services(){
  log "Detectando servicios con autenticación..."
  declare -A auth_ports=(
    [21]="FTP" [22]="SSH" [23]="Telnet" [25]="SMTP"
    [80]="HTTP" [110]="POP3" [143]="IMAP"
    [443]="HTTPS" [3306]="MySQL" [5432]="PostgreSQL"
    [5900]="VNC" [6379]="Redis" [8080]="HTTP-alt"
  )
  for p in $(echo "$PORTS" | tr ',' ' '); do
    if [[ -n "${auth_ports[$p]}" ]]; then
      info "Puerto $p: ${auth_ports[$p]} → posible login"
    fi
  done
}

# ==== CLASIFICACIÓN DE PUERTOS NO ESTÁNDAR RED SOLANA ====
classify_ports(){
  log "Clasificando puertos no estándares..."

  for p in $(echo "$PORTS" | tr ',' ' '); do
    case $p in
      8000) info "$p: Gossip (Solana)";;
      8001) info "$p: Gossip alternativo (Solana)";;
      8899) info "$p: RPC público Solana";;
      8900) info "$p: WebSocket RPC Solana";;
      9000) info "$p: TPU (Transaction Processing Unit) Solana";;
      7000) info "$p: Retransmisión Solana";;
      10000) info "$p: Retransmisión alternativa Solana";;
      8008) info "$p: HTTP proxy o debug service";;
      8015) info "$p: cfg-cloud service";;
      8020) info "$p: intu-ec-svcdisc custom";;
    esac
  done
}

# ==== DETECCIÓN DE NODOS SOLANA ====
detect_solana_node(){
  log "Verificando si el objetivo es un nodo Solana..."

  for port in 8899 8900 8000 8001 9000 7000 10000; do
    timeout 3 bash -c "echo > /dev/tcp/$TARGET/$port" 2>/dev/null && {
      curl -s --max-time 5 "http://$TARGET:$port" | grep -iq "solana" && {
        success "Nodo Solana detectado en puerto $port"
      } || {
        info "Puerto $port abierto pero no responde como nodo Solana"
      }
    }
  done
}

# ==== DETECCIÓN DE VULNERABILIDADES ====
parse_vulnerabilities(){
  log "Analizando CVEs..."
  grep -Eoi 'CVE-[0-9]{4}-[0-9]+' "$OUTPUT_DIR/nmap_vuln.txt" | sort -u > "$OUTPUT_DIR/cves_detectadas.txt"
  while read -r cve; do
    VULNERABILITIES_FOUND+=("$cve")
  done < "$OUTPUT_DIR/cves_detectadas.txt"
  [ ${#VULNERABILITIES_FOUND[@]} -eq 0 ] && info "No se detectaron CVEs."
}

# ==== BUSCAR PoC ====
find_pocs(){
  log "Buscando PoC públicas..."
  for cve in "${VULNERABILITIES_FOUND[@]}"; do
    url="https://www.exploit-db.com/search?q=$cve"
    POC_REFERENCES+=("$cve → $url")
    info "PoC para $cve: $url"
  done
  success "Referencias recopiladas."
}

# ==== REPORTE FINAL ====
generate_report(){
  log "Generando reporte..."
  cat > "$OUTPUT_DIR/reporte_final.txt" <<EOF
=== REPORTE PENTEST ===
Fecha: $(date)
Target: $TARGET
Puertos abiertos: $PORTS

Vulnerabilidades detectadas:
$(printf "%s\n" "${VULNERABILITIES_FOUND[@]:-Ninguna}")

Referencias de PoC:
$(printf "%s\n" "${POC_REFERENCES[@]:-No se encontraron PoC públicas}")
EOF
  success "Reporte creado en $OUTPUT_DIR/reporte_final.txt"
}

# ==== MAIN ====
main(){
  [ "$(id -u)" -ne 0 ] && { echo "Ejecuta con sudo."; exit 1; }

  trap 'error "Interrupción detectada. Saliendo..."; exit 1' INT TERM

  mkdir -p "$OUTPUT_DIR"  # ← Corrección aplicada aquí

  log "Inicio del pentest en $TARGET"

  check_requirements
  full_port_scan
  detailed_scan
  detect_auth_services
  vulnerability_scan
  web_banner_scan
  classify_ports
  detect_solana_node
  parse_vulnerabilities
  find_pocs
  generate_report

  success "Pentest completo. Revisa carpeta $OUTPUT_DIR"
}

main
