#!/bin/bash
# Author: ssmax
# Version: 3.12 corrected
# Description: Ethical pentest script for Solana testnet/mainnet – Stage 1: Reconnaissance

set -euo pipefail
IFS=$'\n\t'

# ==== CONFIGURATION ====
TARGET=${1:-""}
[ -z "$TARGET" ] && { echo "Usage: $0 <target_IP>"; exit 1; }
[[ "$TARGET" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "Invalid IP: $TARGET"; exit 1; }

OUTPUT_DIR="/root/pentest/results/pentest_stage1_$TARGET"
WORDLIST="/usr/share/wordlists/rockyou.txt"
USERLIST="/usr/share/wordlists/usernames.txt"
LOG_FILE="$OUTPUT_DIR/log.txt"or: ssmax
# Versión: 3.12 corregida
# Descripción: Script de pentest ético para Solana testnet/mainnet – Etapa 1: Reconocimiento

set -euo pipefail
IFS=$'\n\t'

# ==== CONFIGURACIÓN ====
TARGET=${1:-""}
[ -z "$TARGET" ] && { echo "Uso: $0 <IP_objetivo>"; exit 1; }
[[ "$TARGET" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "IP inválida: $TARGET"; exit 1; }

OUTPUT_DIR="/root/pentest/results/pentest_etapa1_$TARGET"
WORDLIST="/usr/share/wordlists/rockyou.txt"
USERLIST="/usr/share/wordlists/usernames.txt"
LOG_FILE="$OUTPUT_DIR/log.txt"

# Colors for terminal
RED='\033[0;31m'; GREEN='\033[0;32m'
YELLOW='\033[1;33m'; BLUE='\033[0;34m'; NC='\033[0m'

# Arrays and variables
declare -a VULNERABILITIES_FOUND=()
declare -a POC_REFERENCES=()
PORTS=""
FILTERED_PORTS=""

# ==== LOG FUNCTIONS ====
timestamp(){ date +"%Y-%m-%d %H:%M:%S"; }
log(){ echo -e "${BLUE}[$(timestamp)] [*]${NC} $1" | tee -a "$LOG_FILE"; }
success(){ echo -e "${GREEN}[$(timestamp)] [OK]${NC} $1" | tee -a "$LOG_FILE"; }
error(){ echo -e "${RED}[$(timestamp)] [FAIL] ERROR:${NC} $1" | tee -a "$LOG_FILE"; }
info(){ echo -e "${YELLOW}[$(timestamp)] [!]${NC} $1" | tee -a "$LOG_FILE"; }
warn(){ echo -e "${YELLOW}[$(timestamp)] [WARN]${NC} $1" | tee -a "$LOG_FILE"; }

# ==== SPINNER ====
spinner(){
  local p="$1"; local d=0.1; local s='|/-\'
  while kill -0 "$p" &>/dev/null; do
    local t=${s#?}; printf " [%c]  " "$s"
    s=$t${s%"$t"}; sleep $d; printf "\b\b\b\b\b\b"
  done; printf "      \b\b\b\b\b\b"
}
run_with_spinner(){ "$@" & spinner $!; wait $!; }

# ==== REQUIREMENTS CHECK ====
check_requirements(){
  log "Checking required tools..."
  for t in nmap whatweb httpx curl nuclei; do
    command -v "$t" &>/dev/null || { error "Missing: $t"; return; }
  done
  [ -f "$WORDLIST" ] || { error "Wordlist missing."; exit 1; }
  [ -f "$USERLIST" ] || {
    log "Creating basic userlist..."
    echo -e "root\nadmin\nuser\ntest\nguest" > "$USERLIST"
    success "Userlist created."
  }
}

# ==== PORT SCANNING ====
full_port_scan(){
  log "Scanning TCP ports..."
  run_with_spinner nmap -vv -sS -sV -O -Pn -T4 -p- "$TARGET" -oN "$OUTPUT_DIR/nmap_full.txt"
# PORTS=$(grep 'open' "$OUTPUT_DIR/nmap_full.txt" | cut -d '/' -f1 | paste -sd ',' -)  
  PORTS=$(grep -Eo '^[0-9]+/tcp[[:space:]]+open' "$OUTPUT_DIR/nmap_full.txt" | cut -d '/' -f1 | paste -sd ',' -)
  FILTERED_PORTS=$(grep 'filtered' "$OUTPUT_DIR/nmap_full.txt" | cut -d '/' -f1 | paste -sd ',' -)
  [ -z "$PORTS" ] && { error "No open ports found."; exit 1; }
  success "Open ports: $PORTS"
  [ -n "$FILTERED_PORTS" ] && info "Filtered ports: $FILTERED_PORTS"
}

# ==== DETAILED SCAN ====
detailed_scan(){
  log "Detailed scanning..."
  run_with_spinner nmap -sC -sV --script=banner -p"$PORTS" "$TARGET" -oN "$OUTPUT_DIR/nmap_detail.txt"
  success "Detailed scan completed."
}

# ==== VULNERABILITY SCAN ====
vulnerability_scan(){
  log "Vulnerability scanning with Nmap..."
  run_with_spinner nmap -sV --script vuln -p"$PORTS" "$TARGET" -oN "$OUTPUT_DIR/nmap_vuln.txt"
  success "NSE scan completed."
  grep -iq "VULNERABLE" "$OUTPUT_DIR/nmap_vuln.txt" || info "No obvious vulnerabilities found."

  log "Vulnerability scanning with Nuclei..."
  echo "$TARGET" > "$OUTPUT_DIR/target.txt"
  nuclei -l "$OUTPUT_DIR/target.txt" -o "$OUTPUT_DIR/nuclei_results.txt" -silent || true
  success "Nuclei scan completed."
}

# ==== HTTP SCAN ====
web_banner_scan(){
  log "Checking HTTP ports..."

  local web_ports=()
  for p in $(echo "$PORTS" | tr ',' ' '); do
    if [[ "$p" =~ ^(80|443|8080|8000|8008|8015|8020|8899)$ ]]; then
      web_ports+=("$p")
    fi
  done

  if [ ${#web_ports[@]} -eq 0 ]; then
    info "No web ports detected."
    return
  fi

  log "Scanning HTTP with httpx and whatweb..."
  for p in "${web_ports[@]}"; do
    httpx -silent -p "$p" -host "$TARGET" -title -server -status-code > "$OUTPUT_DIR/httpx_$p.txt" || true
    whatweb "$TARGET:$p" > "$OUTPUT_DIR/whatweb_$p.txt" || true
    success "HTTP scanned @ $p"
  done
}

# ==== AUTHENTICATION SERVICES DETECTION ====
detect_auth_services(){
  log "Detecting authentication services..."
  declare -A auth_ports=(
    [21]="FTP" [22]="SSH" [23]="Telnet" [25]="SMTP"
    [80]="HTTP" [110]="POP3" [143]="IMAP"
    [443]="HTTPS" [3306]="MySQL" [5432]="PostgreSQL"
    [5900]="VNC" [6379]="Redis" [8080]="HTTP-alt"
  )
  for p in $(echo "$PORTS" | tr ',' ' '); do
    if [[ -n "${auth_ports[$p]}" ]]; then
      info "Port $p: ${auth_ports[$p]} → possible login"
    fi
  done
}

# ==== NON-STANDARD SOLANA NETWORK PORTS CLASSIFICATION ====
classify_ports(){
  log "Classifying non-standard ports..."

  for p in $(echo "$PORTS" | tr ',' ' '); do
    case $p in
      8000) info "$p: Gossip (Solana)";;
      8001) info "$p: Alternative Gossip (Solana)";;
      8899) info "$p: Solana public RPC";;
      8900) info "$p: Solana WebSocket RPC";;
      9000) info "$p: TPU (Transaction Processing Unit) Solana";;
      7000) info "$p: Solana retransmission";;
      10000) info "$p: Alternative Solana retransmission";;
      8008) info "$p: HTTP proxy or debug service";;
      8015) info "$p: cfg-cloud service";;
      8020) info "$p: intu-ec-svcdisc custom";;
    esac
  done
}

# ==== SOLANA NODE DETECTION ====
detect_solana_node(){
  log "Checking if target is a Solana node..."

  for port in 8899 8900 8000 8001 9000 7000 10000; do
    timeout 3 bash -c "echo > /dev/tcp/$TARGET/$port" 2>/dev/null && {
      curl -s --max-time 5 "http://$TARGET:$port" | grep -iq "solana" && {
        success "Solana node detected on port $port"
      } || {
        info "Port $port open but doesn't respond as Solana node"
      }
    }
  done
}

# ==== VULNERABILITY DETECTION ====
parse_vulnerabilities(){
  log "Analyzing CVEs..."
  if [ ! -s "$OUTPUT_DIR/nmap_vuln.txt" ]; then
    error "nmap_vuln.txt file not found or empty. Cannot analyze CVEs."
    return
  fi
  grep -Eoi 'CVE-[0-9]{4}-[0-9]+' "$OUTPUT_DIR/nmap_vuln.txt" | sort -u > "$OUTPUT_DIR/detected_cves.txt"
  while read -r cve; do
    VULNERABILITIES_FOUND+=("$cve")
  done < "$OUTPUT_DIR/detected_cves.txt"
  [ ${#VULNERABILITIES_FOUND[@]} -eq 0 ] && info "No CVEs detected."
  if [ -s "$OUTPUT_DIR/detected_cves.txt" ]; then
    info "CVEs file generated correctly: $OUTPUT_DIR/detected_cves.txt"
  else
    info "CVEs file was not generated."
  fi
}

# ==== FIND PoC ====
find_pocs(){
  log "Searching for public PoCs..."
  for cve in "${VULNERABILITIES_FOUND[@]}"; do
    url="https://www.exploit-db.com/search?q=$cve"
    POC_REFERENCES+=("$cve → $url")
    info "PoC for $cve: $url"
  done
  success "References collected."
}

# ==== FINAL REPORT ====
generate_report(){
  log "Generating report..."
  cat > "$OUTPUT_DIR/final_report.txt" <<EOF
=== PENTEST REPORT ===
Date: $(date)
Target: $TARGET
Open ports: $PORTS

Detected vulnerabilities:
$(printf "%s\n" "${VULNERABILITIES_FOUND[@]:-None}")

PoC references:
$(printf "%s\n" "${POC_REFERENCES[@]:-No public PoCs found}")
EOF
  success "Report created at $OUTPUT_DIR/final_report.txt"
}

# ==== MAIN ====
main(){
  [ "$(id -u)" -ne 0 ] && { echo "Run with sudo."; exit 1; }

  trap 'error "Interruption detected. Exiting..."; exit 1' INT TERM

  mkdir -p "$OUTPUT_DIR"  # ← Correction applied here 21/8/2025 ssmsx

  log "Starting pentest on $TARGET"

  check_requirements
  full_port_scan
  detailed_scan
  detect_auth_services
  vulnerability_scan
  web_banner_scan
  classify_ports
  detect_solana_node
  parse_vulnerabilities
  find_pocs
  generate_report

  success "Pentest complete. Check folder $OUTPUT_DIR"
}

main
